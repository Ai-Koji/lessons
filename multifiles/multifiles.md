# Лекция: Многофайловые проекты на языке C

## Зачем нужна многофайловость
Представим себе main.c, который содержит 1 000 или 2 000 строк реализации проекта, в таком файле мы будем просто путаться, не понимая как это все работает, где находится переменная, как она называется и т.д. Поэтому в крупных проектах на языке C программы часто состоят из множества файлов. Это облегчает управление кодом, его чтение и сопровождение.

Помимо этого разделение проекта на несколько файлов дает возможность в параллельной разработке с git. Допустим нас двое и мы оба на разных ветках редактируем один и тот же файл main.c. в таком случае при слиянии(git merge) у нас будут появляться конфликты, которые нужно будет исправлять во время слияния.


## Для чего нужна шапка
Представим, что мы пишем небольшую библиотеку для работы с математикой и уже успели создать функции и пременили их без обьявления:

файл main.c
```C
#include <stdio.h>

int main() {
    // используем функцию
    int ans = sum(1, 2);
    printf("%d", ans);

    return 0;
}

// определяем функцию
int sum (int a, int b) {
    return a + b;
}
```
При компиляции этой программы, компилятор выдаст ошибку:
```
test.c: In function ‘main’:
test.c:4:15: warning: implicit declaration of function ‘sum’ [-Wimplicit-function-declaration]
    4 |     int ans = sum(1, 2);
```
Она означает, что функция не была найдена, поэтому нам нужно указать, что в данном файле где-то лежит функция:
```C
#include <stdio.h>

// обьявляем функцию
int sum(int a, int b); // шапка функции

int main() {
    // используем функцию
    int ans = sum(1, 2);
    printf("%d", ans);

    return 0;
}

// определяем функцию
int sum (int a, int b) {
    return a + b;
}
```
Когда мы прописываем шапку функции, мы даем компилятору понять, что где-то в файле уже есть эта функция. 

## компиляция
1. Компилятор:
  - Компилятор преобразует препроцессированный код в объектный файл (.o). Объектный файл содержит машинный код, но он еще не является самостоятельной программой. Он содержит только код из одного файла и не содержит ссылки на функции из других файлов.

2. Объектный файл:

  - Объектный файл - это промежуточный результат компиляции. Он содержит машинный код - набор инструкций, которые понимает процессор. Объектный файл зависит от архитектуры процессора (например, x86, ARM).

3. Линковка (компиновка):

  - Линковка - это процесс объединения нескольких объектных файлов, которые были скомпилированы отдельно, в единый исполняемый файл. Линковщик:
   - Разрешает ссылки между объектами, соединяя функции и переменные из разных файлов. 
   - Добавляет стандартные библиотеки (например, библиотеку ввода/вывода), которые используются в программе.

4. Исполняемый файл:

  - Результатом линковки является исполняемый файл (.exe на Windows, .out на Linux). Это самостоятельная программа, которую можно запускать на компьютере. 

![image](https://github.com/user-attachments/assets/5a9198cb-7a25-4f08-ad7c-76cec42a9a00)

## Многофайловость
#### структура проекта
Рассмотрим простой проект, состоящий из нескольких файлов:
```go
project/
├── main.c
├── func.c
└── func.h
```

#### Заголовочный файл: func.h
```C
// func.h
#ifndef FUNC_H
#define FUNC_H

void func1(void);
void func2(void);
void func3(void);

#endif // FUNC_H
```
В данном файле мы обьявляем функции, добавляем их шапки.
ifndef define и endif предотвращают многократное включение одного и того же заголовочного файла в разных частях программы. Этот механизм называется "защитой от многократного включения" (include guard).

#### Файл реализации: func.c
```C
// func.c
#include "func.h"
#include <stdio.h>

void func1(void) {
    printf("Function 1\n");
}

void func2(void) {
    printf("Function 2\n");
}

void func3(void) {
    printf("Function 3\n");
}
```
Здесь же,в отличие от заголовочного, мы реализуем эти функции. В начале необходимо прописать include с заголовочным файлом, это необходимо для того, чтобы компилятор сообщил нам о том, что функция отличается от функции в заголовке. Например:

func.c:
```C
void func1(int a);
```

func.h:
```C
void func2(int a);
```

#### Глобальный файл: main.c
```C
// main.c
#include "func.h"

int main() {
    func1();
    func2();
    func3();
    
    return 0;
}
```
Для того, чтобы использовать функции в главном файле, нужно импортировать заголовочный файл через кавычки.

include "..." - локальная библиотека, указывает заголовочкный файл в данной директории, где лежит файл.
include <...> - подключает из стандартной директории include, обычно в директории компилятора/системы
![image](https://github.com/user-attachments/assets/dce3c7e6-fd56-4331-960f-575e883dd414)


## компиляция многофайлового проекта
Для компиляции многофайлового проекта, первым делом нам надо скомпилировать каждый файл отдельно в обьект, затем сделать линковку(компоновку) обьектов в один исполняемый файл.
```bash
gcc -c main.c
gcc -c func.c
gcc -o a.out main.c func.c 
```
-s компилирует его в ассемблер

-c компилирует код в ассемблер, затем ассемблирует его в обьект

-o выводит все в один файл, можно проводить все без него


Компиляция выглядит сложно и неудобно, поэтому для автоматизации компиляции и линковки есть make

### make
make - это инструмент автоматизации сборки, который помогает управлять процессом компиляции и линковки программ.

Создадим файл "Makefile" и заполним его следующим содержимым
```make
all : Project

Project : main.o func.o
	gcc -o a.exe main.o func.o

main.o : main.c
	gcc -c main.c

func.o : func.c
	gcc -c func.c

clean:
	rm Project *.o
```
Теперь, чтобы провести компиляцию и линковку, нам нужно ввести make.

## Правила использования h файлов
1. каждому .h файлу соответствует свой .с файл;
2. в файле с определениямми должен быть #include файла с обьявлениями;
3. больше одного main не должно быть;
