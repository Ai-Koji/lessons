# Лекция: Многофайловые проекты на языке C

## Зачем нужна многофайловость
Представим себе main.c, который содержит 1 000 или 2 000 строк реализации проекта, в таком файле мы будем просто путаться, не понимая как это все работает, где находится переменная, как она называется и т.д. Поэтому в крупных проектах на языке C программы часто состоят из множества файлов. Это облегчает управление кодом, его чтение и сопровождение.

Помимо этого разделение проекта на несколько файлов дает возможность в параллельной разработке с git. Допустим нас двое и мы оба на разных ветках редактируем один и тот же файл main.c. в таком случае при слиянии(git merge) у нас будут появляться конфликты, которые нужно будет исправлять во время слияния.


## Для чего нужна шапка
Представим, что мы пишем небольшую библиотеку для работы с математикой и уже успели создать функции и пременили их без обьявления:

файл main.c
```C
#include <stdio.h>

int main() {
    // используем функцию
    int ans = sum(1, 2);
    printf("%d", ans);

    return 0;
}

// определяем функцию
int sum (int a, int b) {
    return a + b;
}
```
При компиляции этой программы, компилятор выдаст ошибку:
```
test.c: In function ‘main’:
test.c:4:15: warning: implicit declaration of function ‘sum’ [-Wimplicit-function-declaration]
    4 |     int ans = sum(1, 2);
```
Она означает, что функция не была найдена, поэтому нам нужно указать, что в данном файле где-то лежит данный функция:
```C
#include <stdio.h>

// обьявляем функцию
int sum(int a, int b); // шапка функции

int main() {
    // используем функцию
    int ans = sum(1, 2);
    printf("%d", ans);

    return 0;
}

// определяем функцию
int sum (int a, int b) {
    return a + b;
}
```
Когда мы прописываем шапку функции, мы даем компилятору понять, что где-то в файле уже есть эта функция. 

## компиляция
1. Компилятор:
  - Компилятор преобразует препроцессированный код в объектный файл (.o). Объектный файл содержит машинный код, но он еще не является самостоятельной программой. Он содержит только код из одного файла и не содержит ссылки на функции из других файлов.

2. Объектный файл:

  - Объектный файл - это промежуточный результат компиляции. Он содержит машинный код - набор инструкций, которые понимает процессор. Объектный файл зависит от архитектуры процессора (например, x86, ARM).

3. Линковка (связывание):

  - Линковка - это процесс объединения нескольких объектных файлов, которые были скомпилированы отдельно, в единый исполняемый файл. Линковщик:
   - Разрешает ссылки между объектами, соединяя функции и переменные из разных файлов. 
   - Выделяет память для глобальных переменных.
   - Добавляет стандартные библиотеки (например, библиотеку ввода/вывода), которые используются в программе.

4. Исполняемый файл:

  - Результатом линковки является исполняемый файл (.exe на Windows, .out на Linux). Это самостоятельная программа, которую можно запускать на компьютере. 

![image](https://github.com/user-attachments/assets/5a9198cb-7a25-4f08-ad7c-76cec42a9a00)

## Многофайловость
#### структура проекта
Рассмотрим простой проект, состоящий из нескольких файлов:
```go
project/
├── main.c
├── func.c
└── func.h
```

#### Заголовочный файл: func.h
```C
// func.h
#ifndef FUNC_H
#define FUNC_H

void func1(void);
void func2(void);
void func3(void);

#endif // FUNC_H
```
В данном файле мы обьявляем функции, добавляем их шапки.
ifndef define и endif предотвращают многократное включение одного и того же заголовочного файла в разных частях программы. Этот механизм называется "защитой от многократного включения" (include guard).

#### Файл реализации: func.c
```C
// func.c
#include "func.h"
#include <stdio.h>

void func1(void) {
    printf("Function 1\n");
}

void func2(void) {
    printf("Function 2\n");
}

void func3(void) {
    printf("Function 3\n");
}
```
Здесь же,в отличие от заголовочного, мы реализуем эти функции. В начале необходимо прописать include с заголовочным файлом, это необходимо для того, чтобы компилятор сообщил нам о том, что функция отличается от функции в заголовке. Например:

func.c:
```C
void func1(int a);
```

func.h:
```C
void func2(int a);
```

#### Глобальный файл: main.c
```C
// main.c
#include "func.h"

int main() {
    func1();
    func2();
    func3();
    
    return 0;
}
```
Для того, чтобы использовать функции в главном файле, нужно импортировать заголовочный файл через кавычки.

## компиляция многофайлового проекта
```bash
gcc -c main.c
gcc -c func.c
gcc -o a.out main.c func.c 
```
-c компилирует код в обьект
-o делает линковку из нескольких обьектов


## Правила использования h файлов
1. каждому .h файлу соответствует свой .с файл
2. в файле с определениямми должен быть #include файла с обьявлениями

## глобальные переменные.
Если нужно использовать глобальные переменные в нескольких файлах, их объявляют в заголовочном файле с использованием ключевого слова extern.

globals.h:
```C
// globals.h
#ifndef GLOBALS_H
#define GLOBALS_H

extern int globalVar; // Объявление глобальной переменной

#endif // GLOBALS_H
```

globals.c:
```C
// globals.c
#include "globals.h"

int globalVar = 0; // Определение глобальной переменной
```

main.c:
```C
// main.c
#include <stdio.h>
#include "globals.h"

int main() {
    globalVar = 10;
    printf("Global variable: %d\n", globalVar);
    
    return 0;
}
```
